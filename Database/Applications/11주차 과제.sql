SQL> SELECT JOB, ENAME, SAL,
  2  RANK() OVER (ORDER BY SAL DESC) ALL_RANK,
  3  RANK() OVER (PARTITION BY JOB ORDER BY SAL DESC) JOB_RANK
  4  FROM EMP;

SQL> SELECT JOB, ENAME, SAL,
  2  RANK() OVER (ORDER BY SAL DESC) RANK,
  3  DENSE_RANK() OVER (ORDER BY SAL DESC) DENSE_RANK
  4  FROM EMP;

SQL> SELECT JOB, ENAME, SAL,
  2  RANK() OVER (ORDER BY SAL DESC) RANK,
  3  ROW_NUMBER() OVER (ORDER BY SAL DESC) ROW_NUMBER
  4  FROM EMP;

SQL> SELECT MGR, ENAME, SAL,
  2  MAX(SAL) OVER (PARTITION BY MGR) AS MGR_MAX
  3  FROM EMP;

SQL> SELECT MGR, ENAME, SAL
  2  FROM (SELECT MGR, ENAME, SAL, MAX(SAL) OVER (PARTITION BY MGR) AS IV_MAX_SAL
  3  FROM EMP)
  4  WHERE SAL = IV_MAX_SAL;

SQL> SELECT MGR, ENAME, HIREDATE, SAL,
  2  MIN(SAL) OVER (PARTITION BY MGR ORDER BY HIREDATE RANGE UNBOUNDED PRECEDING) AS MGR_MIN
  3  FROM EMP;

SQL> SELECT MGR, ENAME, SAL,
  2  SUM(SAL) OVER (PARTITION BY MGR ORDER BY SAL RANGE  UNBOUNDED PRECEDING) AS MGR_SUM
  3  FROM EMP;

SQL> SELECT MGR, ENAME, HIREDATE, SAL,
  2  ROUND (AVG(SAL) OVER (PARTITION BY MGR ORDER BY HIREDATE
  3  ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)) AS MGR_AVG
  4  FROM EMP;

SQL> SELECT ENAME, SAL,
  2  COUNT(*) OVER (ORDER BY SAL
  3  RANGE BETWEEN 50 PRECEDING AND 150 FOLLOWING) AS MOV_COUNT
  4  FROM EMP;

SQL> SELECT DEPTNO, ENAME, SAL,
  2  FIRST_VALUE(ENAME) OVER
  3  (PARTITION BY DEPTNO ORDER BY SAL DESC, ENAME ASC ROWS UNBOUNDED PRECEDING)
  4  AS RICH_EMP
  5  FROM EMP;

SQL> SELECT DEPTNO, ENAME, SAL,
  2  LAST_VALUE(ENAME) OVER
  3  (PARTITION BY DEPTNO ORDER BY SAL DESC
  4  ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
  5  AS DEPT_POOR
  6  FROM EMP;

SQL> SELECT ENAME, HIREDATE, SAL,
  2  LAG(SAL) OVER (ORDER BY HIREDATE) AS PREV_SAL
  3  FROM EMP
  4  WHERE JOB='SALESMAN';

SQL> SELECT ENAME, HIREDATE, SAL,
  2  LAG(SAL, 2, 0) OVER (ORDER BY HIREDATE) AS PREV_SAL
  3  FROM EMP
  4  WHERE JOB  = 'SALESMAN';

SQL> SELECT ENAME, HIREDATE, LEAD(HIREDATE, 1) OVER (ORDER BY HIREDATE) AS "NEXTHIRED"
  2  FROM EMP
  3  WHERE JOB='SALESMAN';

SQL> SELECT ENAME, SAL, ROUND(RATIO_TO_REPORT(SAL) OVER (), 2) AS R_P
  2  FROM EMP
  3  WHERE JOB='SALESMAN';

SQL> SELECT DEPTNO, ENAME, SAL,
  2  PERCENT_RANK() OVER
  3  (PARTITION BY DEPTNO ORDER BY SAL DESC) AS P_R
  4  FROM EMP;

SQL> SELECT DEPTNO, ENAME, SAL,
  2  CUME_DIST() OVER (PARTITION BY DEPTNO ORDER BY SAL DESC)
  3  AS CUME_DIST
  4  FROM EMP;

SQL> SELECT ENAME, SAL,
  2  NTILE(4) OVER (ORDER BY SAL DESC) AS QUAR_TILE
  3  FROM EMP;


CONN SYSTEM/1234

// 오라클 12c부터 공통 계정 앞에 c## 붙여야 해서 
alter session set "_ORACLE_SCRIPT"=true;

//SCOTT 없어서 생성해줌
SQL> create user SCOTT identified by TIGER
  2  DEFAULT TABLESPACE USERS
  3  TEMPORARY TABLESPACE TEMP;
GRANT CONNECT, RESOURCE, DBA TO SCOTT;

GRANT CREATE USER TO SCOTT;
CONN SCOTT/TIGER
alter session set "_ORACLE_SCRIPT"=true;

CREATE USER PJS IDENTIFIED BY KOREA7;

CONN SYSTEM/1234
GRANT CREATE SESSION TO PJS;
CONN PJS/KOREA7

CONN SYSTEM/1234
GRANT CREATE TABLE TO PJS;
CONN PJS/KOREA7
CREATE TABLE MENU(MENU_SEQ NUMBER NOT NULL, TITLE VARCHAR2(10));

CONN SCOTT/TIGER
SELECT * FROM PJS.MENU;

CONN PJS/KOREA7
GRANT SELECT ON MENU TO SCOTT;
CONN SCOTT/TIGER
SELECT * FROM PJS.MENU;

CONN SYSTEM/1234
CREATE ROLE LOGIN_TABLE;
GRANT CREATE SESSION, CREATE TABLE TO LOGIN_TABLE;
GRANT LOGIN_TABLE TO PJS;
CONN PJS/KOREA7
SQL> CREATE TABLE MENU2(
  2  MENU_SEQ NUMBER NOT NULL,
  3  TITLE VARCHAR2(10));

SQL> CREATE OR REPLACE Procedure p_DEPT_insert
  2  ( v_DEPTNO in number,
  3  v_dname in varchar2,
  4  v_loc in varchar2,
  5  v_result out varchar2)
  6  IS
  7  cnt number := 0;
  8  BEGIN
  9  SELECT COUNT(*) INTO CNT
 10  FROM DEPT
 11  WHERE DEPTNO = v_DEPTNO;
 12  if cnt > 0 then
 13  v_result := '이미 등록된 부서번호이다';
 14  else
 15  INSERT INTO DEPT (DEPTNO, DNAME, LOC)
 16  VALUES (v_DEPTNO, v_dname, v_loc);
 17  COMMIT;
 18  v_result := '입력 완료!!';
 19  end if;
 20  EXCEPTION
 21  WHEN OTHERS THEN
 22  ROLLBACK;
 23  v_result := 'ERROR 발생';
 24  END;
 25  /

SELECT * FROM DEPT;

variable rslt varchar2(30);
EXECUTE p_DEPT_insert(10, 'dev', 'seoul', :rslt);
print rslt;

EXECUTE p_DEPT_insert(50, 'NewDev', 'seoul', :rslt);
print rslt;

SELECT * FROM DEPT;

SQL> CREATE OR REPLACE Function UTIL_ABS
  2  (v_input in number)
  3  return NUMBER
  4  IS
  5  v_return number := 0;
  6  BEGIN
  7  if v_input < 0 then
  8  v_return := v_input * -1;
  9  else
 10  v_return := v_input;
 11  end if;
 12  RETURN v_return;
 13  END;
 14  /

SQL> SELECT SCHE_DATE 경기일자,
  2  HOMETEAM_ID || ' - ' || AWAYTEAM_ID 팀들,
  3  HOME_SCORE || ' - ' || AWAY_SCORE SCORE,
  4  UTIL_ABS(HOME_SCORE - AWAY_SCORE) 점수차
  5  FROM SCHEDULE
  6  WHERE GUBUN = 'Y'
  7  AND SCHE_DATE BETWEEN '20120801' AND '20120831'
  8  ORDER BY SCHE_DATE;

SQL> CREATE TABLE ORDER_LIST(
  2  ORDER_DATE CHAR(8),
  3  PRODUCT VARCHAR2(10),
  4  QTY NUMBER,
  5  AMOUNT NUMBER);

SQL> CREATE TABLE SALES_PER_DATE(
  2  SALE_DATE CHAR(8)
  3  , PRODUCT VARCHAR2(10),
  4  QTY NUMBER,
  5  AMOUNT NUMBER);

SQL> CREATE OR REPLACE Trigger SUMMARY_SALES
  2  AFTER INSERT
  3  ON ORDER_LIST
  4  FOR EACH ROW
  5  DECLARE
  6  o_date ORDER_LIST.order_date%TYPE;
  7  o_prod ORDER_LIST.product%TYPE;
  8  BEGIN
  9  o_date := :NEW.order_date;
 10  o_prod := :NEW.product;
 11  UPDATE SALES_PER_DATE
 12  SET qty = qty + :NEW.qty,
 13  amount = amount + :NEW.amount
 14  WHERE sale_date = o_date
 15  AND product = o_prod;
 16  if SQL%NOTFOUND then
 17  INSERT INTO SALES_PER_DATE
 18  VALUES(o_date, o_prod, :NEW.qty, :NEW.amount);
 19  end if;
 20  END;
 21  /

INSERT INTO ORDER_LIST VALUES('20120901', 'MONOPACK', 10, 300000);
COMMIT;
SELECT * FROM ORDER_LIST;
SELECT * FROM SALES_PER_DATE;

INSERT INTO ORDER_LIST VALUES('20120901', 'MONOPACK', 20, 600000);
COMMIT;
SELECT * FROM ORDER_LIST;
SELECT * FROM SALES_PER_DATE;

